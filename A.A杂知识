string s2 = s.substr(start_index, length);
//参数 1 (start_index)：从哪个下标开始切（从 0 开始计数）。
//参数 2 (length)：可选。要切多长。如果不写这个参数，默认切到字符串末尾。





1. Vector（向量/动态数组）
这就是你理解的“不限制长度的数组”。
形象比喻：记事本。
你可以按顺序一行一行写（push_back）。
你可以写重复的内容。
你可以随时翻到第 10 页看写了什么（v[10]，下标访问）。
特点：
连续存储：和普通数组一样。
访问快：v[i] 是 $O(1)$。
查找慢：想找个东西得从头翻到尾 $O(N)$。
什么时候用：90% 的情况都用它。只要存一堆数据，不需要去重，不需要按内容查找，就用 vector。

2. Set（集合）
它不是数组，它是“严谨的管理员”。
形象比喻：VIP 访客名单。
自动去重：同一个名字写两次，它只记一次。
自动排序：不管你什么时候把名字给它，它永远按 A-Z 排好序。
不能用下标：你不能问“第3个人是谁”（s[3] ❌ 报错），你只能问“张三在不在名单里”（find）。
特点：
树状存储（红黑树）：不是一排连续的格子。
查找快：$O(\log N)$。
插入慢：因为插入时要找位置排序，比 vector 慢。
什么时候用：
需要去重。
需要判断某元素是否存在（像你的 P1032 题）。

3. Map（映射）
它是 Set 的升级版，或者说是“高级数组”。
形象比喻：超市储物柜 或 字典。
Key (键)：储物柜的号码牌（唯一的，自动排序）。
Value (值)：柜子里存的包（可以重复，随便改）。
特点：
vector 的下标只能是 整数 (v[0], v[1])。
map 的下标可以是 任何东西！(m["apple"], m["张三"])。
关系：
set 其实就是一个 只有 Key 没有 Value 的 map。
什么时候用：
统计单词出现的次数（Key=单词，Value=次数）。
需要把字符串映射成数字。

map&set输入输出：
set一般用insert输入
s.insert（内容）
map也可以用insert，还可以直接输入，默认value为0
m.insert(" , ")
m[" "]=_

查找都用count
set返回bool，map返回valude的值

遍历
for(auto i :s/m)
如果是map的话，i是一个pair（struct一对）
用i.first,i.second来访问key和valude




// cin >> string 会返回流对象，读不到东西时会变 false
    while (cin >> key[rule_count] >> value[rule_count]) {
        rule_count++;
    }
