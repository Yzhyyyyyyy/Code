// ==================== 核心区分：区间 DP vs 树状 DP ====================
// 很多题目披着“树”的外衣，实际上是“区间 DP”。
// 判别核心：看树是【原本就存在的】还是【你需要去构建的】。

/* 
   【类型一：真·树状 DP】
   1. 题目特征：
      - 输入明确给出了边（u, v）或父子关系。
      - 树的形态是固定的，不可改变。
      - 题目通常问：在这棵树上选点、染色、覆盖能得到的最大值。
   2. 核心逻辑：
      - 依赖关系：父节点依赖子节点。
      - 遍历方式：DFS / 后序遍历（先递归子节点，回溯时更新父节点）。
   3. 状态定义：
      - dp[u][...]：以 u 为根的子树...
   4. 复杂度：
      - 通常 O(N) 或 O(N^2)（树上背包）。
*/

// 典型代码骨架 (Tree DP)
void dfs(int u, int fa) {
    for (int v : adj[u]) {
        if (v == fa) continue;
        dfs(v, u); // 1. 先下钻
        // 2. 回溯更新 dp[u]
        dp[u] += dp[v]; 
    }
}


/* 
   【类型二：伪·树状 DP（实为区间 DP）】
   1. 题目特征：
      - 输入是一个序列（数组、字符串），没有给出具体的边。
      - 题目要求：通过合并、切分、选根，构造出一棵最优的树（或结构）。
      - 关键词：“中序遍历为 1..n”、“矩阵连乘”、“最优二叉搜索树”。
   2. 核心逻辑：
      - 依赖关系：大区间依赖小区间。
      - 遍历方式：枚举区间长度 len -> 枚举左端点 l -> 枚举分割点 k。
   3. 状态定义：
      - dp[l][r]：区间 [l, r] 形成一棵子树/合并成一个整体的最优值。
   4. 复杂度：
      - 通常 O(N^3)。
*/

// 典型代码骨架 (Interval DP)
// 针对 P1040 加分二叉树
void solve_interval() {
    // 1. 枚举长度
    for (int len = 2; len <= n; len++) {
        // 2. 枚举左端点
        for (int l = 1; l <= n - len + 1; l++) {
            int r = l + len - 1;
            // 3. 枚举分割点 (即：谁当根？)
            for (int k = l; k <= r; k++) {
                // 状态转移：左子树 + 右子树 + 根
                dp[l][r] = max(dp[l][r], dp[l][k-1] * dp[k+1][r] + score[k]);
            }
        }
    }
}


// ==================== 一句话必杀技 ====================
// 如果题目给了边 (u, v)，让你在树上跑 ——> 树状 DP (DFS)
// 如果题目给了一排数，让你凑出一棵树 ——> 区间 DP (三层循环)
