时间复杂度对应表
// O(1)      | 无限制    | 直接取值、简单条件判断
// O(logn)   | 接近无限制| 二分查找、快速幂、并查集、树状数组/线段树基础操作
// O(n)      | 10^8      | 数组/链表遍历、线性查找、前缀和/差分
// O(nlogn)  | 4*10^6    | 快速排序、归并排序、堆排序、拓扑排序、Dijkstra（堆优化）
// O(n²)     | 10^4      | 冒泡/选择/插入排序、朴素动态规划、双重循环枚举、Floyd算法
// O(n³)     | 464       | 三重循环暴力求解、Floyd-Warshall多源最短路
// O(2^n)    | 26        | 子集暴力枚举、无优化的组合枚举
// O(n!)     | 10        | 全排列暴力枚举、无剪枝的排列组合求解



1.按照数组重载大小后更新数组
// 时间复杂度 O(n^2) -> 10万数据必超时
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (b[j] == a[i]) c[j] = i; 
    }
}
// 时间复杂度 O(n) -> 极快
// 1. 预处理：记录 A 中每个值的位置
for (int i = 0; i < n; i++) pos[a[i]] = i; 

// 2. 转换：直接把 B 的值换成位置
for (int i = 0; i < n; i++) c[i] = pos[b[i]]; 



2.最长上升子序列
//  传统 DP 写法
// 时间复杂度 O(n^2) -> 10万数据必超时
// 瓶颈：每次都要“回头看”，遍历前面所有节点来找最大值
vector<int> dp(n, 1);
for (int i = 0; i < n; i++) {
    for (int j = 0; j < i; j++) {
        // 如果能接上，就尝试更新长度
        if (nums[i] > nums[j]) {
            dp[i] = max(dp[i], dp[j] + 1);
        }
    }
}


//  贪心 + 二分查找 (Patience Sorting)
// 时间复杂度 O(n log n) -> 极快，可处理百万级数据
// 核心：tails[i] 存储长度为 i+1 的序列中“最小的结尾值”
vector<int> tails;
for (int v : nums) {
    // 1. 二分查找：找到第一个 >= v 的位置 (即“挡路”的那个数)
    auto it = lower_bound(tails.begin(), tails.end(), v);
    
    if (it == tails.end()) {
        // 2. 没找到：说明 v 比所有结尾都大 -> 只有它能让序列变长
        tails.push_back(v);
    } else {
        // 3. 找到了：说明 v 更小更强 -> 踢掉旧数，换上 v (降低门槛，为未来铺路)
        *it = v; 
    }
}
// tails.size() 即为 LIS 长度


