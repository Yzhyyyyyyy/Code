//适用：单源最短路，边权非负
//为什么要有优先队列：
//在步权不相等的情况下，先搜索到的代表步数少，不一定代表花费（路权总和）少
//因此要根据路权的总和再来进行排序

//Sum up:
//“Dijkstra 算法就是在 BFS 的基础上计算了累计路权，并利用优先队列进行排序。”
//“它不单单通过‘是否到达’来判断，而是通过‘路权比较’来决定是否更新；
//每次处理当前节点时，都附带检查周围邻居是否可以通过当前节点更快到达。”

#include <iostream>
#include <vector>
#include <queue>
#include <cstring>

using namespace std;

// 定义无穷大，0x3f3f3f3f 是一个很大的数，且两数相加不会溢出 int
const int INF = 0x3f3f3f3f; 
// 如果题目数据很大，距离可能超过 int，请使用 long long 和 0x3f3f3f3f3f3f3f3fLL
typedef long long ll;

// 边的结构体
struct Edge {
    int to;     // 目标点
    int weight; // 边权
};

// 邻接表存图
// MAXN 根据题目要求修改，通常 1e5 或 2e5
const int MAXN = 100005; 
vector<Edge> adj[MAXN]; 

// dis[i] 存储起点到 i 的最短距离
int dis[MAXN]; 
// vis[i] 标记点 i 是否已经遍历到了
bool vis[MAXN]; 

// s: 起点, n: 点的总数
void dijkstra(int s, int n) {
    // 1. 初始化
    // memset(dis, 0x3f, sizeof(dis)); // 慎用 memset 如果是 long long
    for(int i = 1; i <= n; i++) dis[i] = INF;
    for(int i = 1; i <= n; i++) vis[i] = false;
//如果要问走过的路径是啥：
for(int i = 1; i <= n; i++) pre[i] = -1; // -1 表示没有前驱
   
dis[s] = 0;
    
    // 优先队列，存 pair<距离, 点编号>
    // priority_queue 默认是大根堆，我们需要小根堆（距离最小的在上面）
    // greater 也就是让它变成从小到大排序
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
//此处使用pair，因此可以不需要重载运算符，只需要greater将大顶堆改成小顶堆就可以了

    // 把起点放入队列
    pq.push({0, s});
    
    while (!pq.empty()) {
        // 取出当前距离起点最近的点
        int u = pq.top().second;
        pq.pop();
        
        // 如果这个点已经处理过（即已经找到了最短路），跳过
        if (vis[u]) continue;
        vis[u] = true; // 标记为已处理
        
        // 遍历 u 的所有邻居
        for (auto& edge : adj[u]) {
            int v = edge.to;
            int w = edge.weight;
            
            // 松弛操作：如果通过 u 到 v 比直接去 v 更近
           // 之前的记录：去 v 需要 100 分钟 (dis[v] = 100)
// 现在的发现：我从 u 走到 v，只需要 10 + 5 = 15 分钟

if (dis[v] > dis[u] + w) {  // 100 > 15 ？ 是的！
    dis[v] = dis[u] + w;    // 赶紧更新：去 v 的最短路其实是 15
    pq.push({dis[v], v});   // 把这个新发现放入队列，重新检查 v 的邻居
    pre[v] = u;             // 记录：我是从 u 走过来的，不是直接飞过来的
            }
        }
    }
}


// 打印路径函数（递归法）
// 调用 print_path(终点) 即可
void print_path(int t) {
    if (t == -1) return; // 到了起点的前面，结束
    print_path(pre[t]);  // 先打印前面的
    cout << t << " ";    // 再打印自己
}


// 使用示例
/*
int main() {
    int n, m, s; // n点数, m边数, s起点
    cin >> n >> m >> s;
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        adj[u].push_back({v, w});
        // 如果是无向图，加上下面这句：
        // adj[v].push_back({u, w});
    }
    
    dijkstra(s, n);
    
    // 输出到各点的距离
    for (int i = 1; i <= n; i++) {
        cout << dis[i] << " ";
    }
    return 0;
}
*/
