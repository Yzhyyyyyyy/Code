#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <limits.h>

typedef struct Node {
    char data;
    struct Node *next;
} Node;

// 1. 建表模板：尾插法 (原始直观版)
Node* createList() {
    Node *head, *tail;
    head = (Node *)malloc(sizeof(Node));
    head->next = NULL; 
    tail = head; 


//如果已经存在一个链表，要继续补充内容的话：
//  imf*tail;
//    tail=head;
//    while(tail->next != NULL) {//每一次tail都从head开始，走一遍链表到最后去等待添加新元素
//       tail = tail->next;
//    }


    char c;
    while ((c = getchar()) != '\n') {
        // 四步走：开空间 -> 移指针 -> 存数据 -> 封口
        tail->next = (Node *)malloc(sizeof(Node));
        tail = tail->next;
        tail->data = c;
        tail->next = NULL;
    }
    return head;
}

// 2. 重点：链表转数组 (无冗余)
char* listToArray(Node* head) {
    // 第一步：统计有效节点个数
    int len = 0;
    Node *p = head->next; // 跳过头结点
    while (p != NULL) {
        len++;
        p = p->next;
    }

    // 第二步：申请内存
    // 【关键点】：malloc(len + 1)
    // 多申请这 1 个字节，是专门留给 '\0' 的
    char *arr = (char *)malloc((len + 1) * sizeof(char));

    // 第三步：填充数据
    p = head->next;
    int i = 0;
    while (p != NULL) {
        arr[i] = p->data; // 填数据
        i++;
        p = p->next;
    }

    // 第四步：封口
    arr[i] = '\0'; // 在最后一位盖章，宣布字符串结束

    return arr;
}

// 3. 物理修改模板
void modifyList(Node* head, char key) {
    Node *p = head->next;
    Node *prev = head;
    int found = 0;

    // 删除
    while (p != NULL) {
        if (p->data == key) {
            prev->next = p->next;
            free(p);
            found = 1;
            break;
        }
        prev = p;
        p = p->next;
    }

    // 插入
    if (!found) {
        Node *target = head->next;
        if (target == NULL) target = head; 
        else {
            int minDiff = INT_MAX;
            p = head->next;
            while (p != NULL) {
                int diff = abs(p->data - key);
                if (diff < minDiff) {
                    minDiff = diff;
                    target = p;
                }
                p = p->next;
            }
        }
        // 插入操作
        Node *newNode = (Node *)malloc(sizeof(Node));
        newNode->data = key;
        newNode->next = target->next;
        target->next = newNode;
    }
}

void printList(Node* head) {
    Node *p = head->next;
    while (p != NULL) {
        printf("%c ", p->data);
        p = p->next;
    }
    printf("\n");
}

int main() {
    // 1. 建表
    Node *list = createList();
    
    // 2. 转数组并输出 (题目要求)
    char *str = listToArray(list);
    printf("%s\n", str); // 打印字符串
    free(str); // 用完记得释放数组内存
    
    // 3. 修改
    char key = getchar();
    modifyList(list, key);
    
    // 4. 最终输出
    printList(list);
    
    return 0;
}



//要进行排序的话，将指向数组的指针导入数组中，对数组排序后再改变原来链表的指向关系：

//C:
// 比较函数：注意这里是核心难点
// 传入的是“指针数组”元素的地址，所以是二级指针 (Node**)
int cmp(const void *a, const void *b) {
    Node *nodeA = *(Node**)a; // 解引用一次，拿到节点指针
    Node *nodeB = *(Node**)b;
    
    // 升序：A - B (char 类型直接相减即可)
    // 如果是 int 分数：return nodeA->score - nodeB->score;
    // 如果是降序：return nodeB->data - nodeA->data;
    return nodeA->data - nodeB->data; 
}

void sortList(Node* head) {
    // 0. 特判空链表
    if (head->next == NULL || head->next->next == NULL) return;

    // 1. 统计长度 (为了开辟数组空间)
    int len = 0;
    Node *p = head->next;
    while (p != NULL) {
        len++;
        p = p->next;
    }

    // 2. 创建指针数组 (使用 malloc 动态分配，防止栈溢出)
    Node **arr = (Node **)malloc(len * sizeof(Node*));

    // 3. 填入数据
    p = head->next;
    for (int i = 0; i < len; i++) {
        arr[i] = p;
        p = p->next;
    }

    // 4. 调用 qsort
    // 参数：数组首地址, 元素个数, 每个元素的大小(即指针的大小), 比较函数
    qsort(arr, len, sizeof(Node*), cmp);

    // 5. 重组链表 (最爽的一步)
    Node *tail = head;
    for (int i = 0; i < len; i++) {
        tail->next = arr[i]; // 现在的 arr[i] 已经是排好序的节点了
        tail = tail->next;
    }
    tail->next = NULL; // 【重要】别忘了把尾巴封死，否则会死循环

    // 6. 释放辅助数组
    free(arr);
}

//C++:
#include <vector>
#include <algorithm>
#include <iostream>

// C++ 版本的比较函数 (不需要指针转换，更直观)
bool cpp_cmp(Node* a, Node* b) {
    return a->data < b->data; // 升序
}

void sortListCpp(Node* head) {
    if (!head->next) return;
    
    std::vector<Node*> v;
    Node* p = head->next;
    while(p) {
        v.push_back(p);
        p = p->next;
    }

    // 使用 std::sort
    std::sort(v.begin(), v.end(), cpp_cmp);

    // 重组
    Node* tail = head;
    for(auto node : v) {
        tail->next = node;
        tail = tail->next;
    }
    tail->next = NULL;
}


