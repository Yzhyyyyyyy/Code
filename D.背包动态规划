定义状态 dp[i][j]：在前 $i$ 个物品中选，背包容量为 $j$ 时的最大价值。

不拿第 $i$ 个：dp[i][j] = dp[i-1][j]
拿第 $i$ 个：dp[i][j] = dp[i-1][j - w[i]] + v[i] 
空间优化：一维数组（竞赛通用写法）
我们发现计算 dp[i] 层时，只需要 dp[i-1] 层的数据。所以可以压缩成一维数组 dp[j]。
// w[i]: 重量, v[i]: 价值, V: 背包总容量
vector<int> dp(V + 1, 0);

//数组内的参数表示只考虑这么多的容量
//数组的值表示总共的价值
//dp含义就是只考虑我拥有这么多的预算/空间，我能得到的最大价值

//01背包（每个物品取一次）
for (int i = 0; i < N; i++) {           // 枚举物品
    for (int j = V; j >= w[i]; j--) {   // 【重点】枚举容量：必须倒序！
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
//倒序的目的是为了防止dp[j-w[i]] + v[i]这个值是这一轮才修改了的值，这样会导致同一物品多次选取
//因此相应的完全背包只需要将倒序修改为正序即可


//完全背包（每个物品随便取）
for (int i = 0; i < N; i++) {
    for (int j = w[i]; j <= V; j++) {   // 【重点】枚举容量：改成正序！
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}


//多重背包（每个物品有限个）
//按2的幂次划分，再进行01背包
struct Item { int w, v; };
vector<Item> new_items;
// 假设第 i 种物品：重量 w, 价值 v, 数量 count
for (int k = 1; k <= count; k *= 2) {
    new_items.push_back({k * w, k * v});
    count -= k;
}
if (count > 0) { // 把剩下的打包
    new_items.push_back({count * w, count * v});
}
// 然后对 new_items 跑一遍标准的 0/1 背包


//分组背包（物品存在归属，组内物品不可以重复选取）
vector<int> dp(V + 1, 0); //使用一维动态规划数组
// dp[j]：背包容量为j时，能获得的最大价值
// 定义二维数组group[组数][组内元素数]=元素信息
vector<vector<pair<int, int>>> group(max_g + 1); 
// group[g]：存储第g组的所有物品，每个元素是(重量, 价值)
// 组号一般从1开始，max_g是题目中最大的组号
//遍历每个组 → 倒序遍历背包容量（从V到0） → 遍历组内的每个物品
//或者可以在成串的数据中直接分隔开不同的组，再对不同的组进行01背包
int start = 0;
    while (start < n) {
        // 找到当前组的结束下标end：同组号的最后一个物品的下一个位置
        int end = start;
        while (end < n && num[end].group == num[start].group) {
            end++;
        }
        // 分组背包核心：倒序遍历容量（防止组内重复选）→ 遍历组内物品更新DP
        for (int j = max_weight; j >= 0; j--) { // 倒序遍历背包容量
            for (int k = start; k < end; k++) { // 遍历当前组的所有物品
                // 容量足够时，执行01背包式状态转移
                if (j >= num[k].weight) {
                    dp[j] = max(dp[j], dp[j - num[k].weight] + num[k].value);
//涵盖了所有物品都不取的情况，每次都取dp[j]
                }
            }
        }
        start = end; // 移到下一组的起始位置，继续处理
    }



//主附件背包（选择A的前提是必须选择B）
//将主件A和附件的所有组合的可能情况全部枚举出来生成新的可能情况，再对所有情况跑01背包
//可以使用二进制手段，从1到（1<<（end-start）），用for循环遍历，看>>j之后&1是为1还是为0,
//以此来决定是不是将其加入price_now和value_now之中
//这样就可以达到，遍历所有的附件取或者不取的所有情况了
//前面要先进行排序：
struct Item {
    int id;     // 物品原本的编号
    int price;  // 价格
    int value;  // 价格 * 重要度
    int q;      // 主件编号 (0表示自己是主件)
    int family; // 用来排序的组号
};
// 排序规则：把同一组的放一起，且主件排在最前面
bool cmp(Item a, Item b) {
    if (a.family != b.family) {
        return a.family < b.family; // 按组号排序
    }
    // 如果组号相同（是同一家子），主件(q=0)排在前面
    return a.q < b.q;
}
   // 确定组号：如果是主件，组号就是自己；如果是附件，组号是它大哥的编号
        if (num[i].q == 0) num[i].family = i;
        else num[i].family = num[i].q;
    }
 // 【关键步骤】排序！
    // 排序后，数组变成了：[主件A, 附件A1, 附件A2, 主件B, 附件B1, ...]
    sort(num.begin() + 1, num.end(), cmp);

int start = 1;
    while (start <= n) {
        // 此时 num[start] 一定是主件
        int end = start + 1;
        
        // 寻找当前主件的所有附件 (因为排过序，它们一定紧跟在后面)
        // 注意：这里判断 family 是否相同即可
        while (end <= n && num[end].family == num[start].family)
            end++;
            
        // 这一组里的附件数量
        // start是主件，start+1 到 end-1 是附件
        int accessories_cnt = end - start - 1; 
        
        // --- 预处理：生成这一组所有可能的购买方案 (价格, 价值) ---
        // 这一步是为了防止在DP循环里重复购买
        vector<pair<int, int>> combos;
        
        // 二进制枚举附件的所有组合
        for (int i = 0; i < (1 << accessories_cnt); i++) {
            int price_now = num[start].price; // 必选主件
            int value_now = num[start].value;
            
            for (int j = 0; j < accessories_cnt; j++) {
                if ((i >> j) & 1) { // 如果二进制第j位是1，代表选第j个附件
                    price_now += num[start + 1 + j].price;
                    value_now += num[start + 1 + j].value;
                }
            }
            
            if (price_now <= max_price) {
                combos.push_back({price_now, value_now});
            }
        }

        // --- 分组背包 DP ---
        // 1. 先遍历容量 (倒序)
        for (int j = max_price; j >= 0; j--) {
            // 2. 再遍历这一组所有的组合方案
            for (auto &combo : combos) {
                int cost = combo.first;
                int val = combo.second;
                if (j >= cost) {
                    dp[j] = max(dp[j], dp[j - cost] + val);
                }
            }
        }

        // 移动 start 指针到下一组
        start = end;
    }



//不只有最值背包，还可以有可行性背包，定义为bool dp，状态转移方程把最大值换成||
  dp[j]==dp[i]||dp[i-arr[i]];
