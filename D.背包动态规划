定义状态 dp[i][j]：在前 $i$ 个物品中选，背包容量为 $j$ 时的最大价值。

不拿第 $i$ 个：dp[i][j] = dp[i-1][j]
拿第 $i$ 个：dp[i][j] = dp[i-1][j - w[i]] + v[i] 
空间优化：一维数组（竞赛通用写法）
我们发现计算 dp[i] 层时，只需要 dp[i-1] 层的数据。所以可以压缩成一维数组 dp[j]。
// w[i]: 重量, v[i]: 价值, V: 背包总容量
vector<int> dp(V + 1, 0);

//数组内的参数表示目前背包剩余的容量
//数组的值表示总共的价值

//01背包（每个物品取一次）
for (int i = 0; i < N; i++) {           // 枚举物品
    for (int j = V; j >= w[i]; j--) {   // 【重点】枚举容量：必须倒序！
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}
//倒序的目的是为了防止dp[j-w[i]] + v[i]这个值是这一轮才修改了的值，这样会导致同一物品多次选取
//因此相应的完全背包只需要将倒序修改为正序即可


//完全背包（每个物品随便取）
for (int i = 0; i < N; i++) {
    for (int j = w[i]; j <= V; j++) {   // 【重点】枚举容量：改成正序！
        dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
    }
}


//多重背包（每个物品有限个）
//按2的幂次划分，再进行01背包
struct Item { int w, v; };
vector<Item> new_items;
// 假设第 i 种物品：重量 w, 价值 v, 数量 count
for (int k = 1; k <= count; k *= 2) {
    new_items.push_back({k * w, k * v});
    count -= k;
}
if (count > 0) { // 把剩下的打包
    new_items.push_back({count * w, count * v});
}
// 然后对 new_items 跑一遍标准的 0/1 背包


//分组背包（物品存在归属，组内物品不可以重复选取）
vector<int> dp(V + 1, 0); //使用一维动态规划数组
// dp[j]：背包容量为j时，能获得的最大价值
// 定义二维数组group[组数][组内元素数]=元素信息
vector<vector<pair<int, int>>> group(max_g + 1); 
// group[g]：存储第g组的所有物品，每个元素是(重量, 价值)
// 组号一般从1开始，max_g是题目中最大的组号
//遍历每个组 → 倒序遍历背包容量（从V到0） → 遍历组内的每个物品
//或者可以在成串的数据中直接分隔开不同的组，再对不同的组进行01背包
int start = 0;
    while (start < n) {
        // 找到当前组的结束下标end：同组号的最后一个物品的下一个位置
        int end = start;
        while (end < n && num[end].group == num[start].group) {
            end++;
        }
        // 分组背包核心：倒序遍历容量（防止组内重复选）→ 遍历组内物品更新DP
        for (int j = max_weight; j >= 0; j--) { // 倒序遍历背包容量
            for (int k = start; k < end; k++) { // 遍历当前组的所有物品
                // 容量足够时，执行01背包式状态转移
                if (j >= num[k].weight) {
                    dp[j] = max(dp[j], dp[j - num[k].weight] + num[k].value);
//涵盖了所有物品都不取的情况，每次都取dp[j]
                }
            }
        }
        start = end; // 移到下一组的起始位置，继续处理
    }


//主附件背包（选择A的前提是必须选择B）
//将主件A和附件的所有组合的可能情况全部枚举出来生成新的可能情况，再对所有情况跑01背包




//不只有最值背包，还可以有可行性背包，定义为bool dp，状态转移方程把最大值换成||
  dp[j]==dp[i]||dp[i-arr[i]];
