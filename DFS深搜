// DFS
#include<iostream>
using namespace std;
//定义方向数组方便移动
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
//迷宫n行m列
//num为已知条件，path记录可行路径
int islaw(int tx,int ty,int n,int m,int num[][m],int path[][m]) {
    if(tx<n&&ty<m&&num[tx][ty]==1&&path[tx][ty]==0&&tx>=0&&ty>=0)
        return 1;
    else return 0;
}


void DFS(int x,int y,int m,int n,int num[][m],int path[][m]) {
    //重点：先写返回函数
    // ① 如果完成一条路径，函数返回
if (x==n-1&&y==m-1) {
    //进行操作（打印，计数...)
}else {
    // 标记该位置并移动，进行递推
    for(int d=0;d<4;d++){//重点：此处使用循环，确保每个位置检查了四个方向
        int tx=x+dx[d];
        int ty=y+dy[d];
        if(islaw(tx,ty,n,m,num,path)){
            path[tx][ty]=1;//如果可以移动，进行移动，并标记点位已经走到
            DFS(tx,ty,m,n,num,path);
            //  如果路不通，返回到箭头处，进行回溯
            path[tx][ty]=0;
            //  回溯完成后仍在循环中，进行接下来的方向判定
            // TIP: 提前结束也要回溯，使这一段没有产生改变
        }
    }
      }
}
