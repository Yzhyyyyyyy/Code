// DFS
#include<iostream>
using namespace std;
//定义方向数组方便移动
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
//迷宫n行m列
//num为已知条件，path记录可行路径
//num中1表示可以行走，path中1表示已经走过（不可行走）
int islaw(int tx,int ty,int n,int m,int num[][m],int path[][m]) {
    if(tx<n&&ty<m&&num[tx][ty]==1&&path[tx][ty]==0&&tx>=0&&ty>=0)
        return 1;
    else return 0;
}


void DFS(int x,int y,int m,int n,int num[][m],int path[][m]) {
    //重点：先写返回函数
    // ① 如果完成一条路径，函数返回
if (x==n-1&&y==m-1) {
    //进行操作（打印，计数...）
}else {
    // 标记该位置并移动，进行递推
    for(int d=0;d<4;d++){//重点：此处使用循环，确保每个位置检查了四个方向
        int tx=x+dx[d];
        int ty=y+dy[d];
        if(islaw(tx,ty,n,m,num,path)){
            path[tx][ty]=1;//如果可以移动，进行移动，并标记点位已经走到
            DFS(tx,ty,m,n,num,path);
            //  如果路不通，返回到箭头处，进行回溯
            path[tx][ty]=0;
            //  回溯完成后仍在循环中，进行接下来的方向判定
            // TIP: 提前结束也要回溯，使这一段没有产生改变
        }
    }
      }
}



//n皇后问题
int law(int x, int y, int n, int num[30][4]) {
    // 检查列、主对角线、副对角线是否被占用
    if (num[y][1] == 0 && num[x - y + n][2] == 0 && num[x + y][3] == 0)
        return 1;
    else
        return 0;
}

void dfs(int x, int *di, int n, int result[100000][13], int num[30][4], int current[13]) {
    if (x == n) {
        // 重点：保存当前解
//如果没有current数组，每次尝试都会修改result中的值，导致输出时result中不是一组正确答案，而是每个位置最后一次尝试成功的值
        for (int i = 0; i < n; i++) {
            result[*di][i] = current[i];
        }
        (*di)++;
        return;
    }
    for (int y = 0; y < n; y++) {
        if (law(x, y, n, num)) {
            current[x] = y + 1;  // 记录当前选择
            
            // 标记占用
            num[y][1] = 1;
            num[x - y + n][2] = 1;
            num[x + y][3] = 1;
            
            dfs(x + 1, di, n, result, num, current);
            
            // 回溯
            num[y][1] = 0;
            num[x - y + n][2] = 0;
            num[x + y][3] = 0;
        }
    }
}
