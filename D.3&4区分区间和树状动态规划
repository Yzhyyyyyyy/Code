// ==================== 核心区分：区间 DP vs 树状 DP ====================
// 很多题目披着“树”的外衣，实际上是“区间 DP”。
// 判别核心：看树是【原本就存在的】还是【你需要去构建的】。

/* 
   【类型一：真·树状 DP】
   1. 题目特征：
      - 输入明确给出了边（u, v）或父子关系。
      - 树的形态是固定的，不可改变。
      - 题目通常问：在这棵树上选点、染色、覆盖能得到的最大值。
   2. 核心逻辑：
      - 依赖关系：父节点依赖子节点。
      - 遍历方式：DFS / 后序遍历（先递归子节点，回溯时更新父节点）。
   3. 状态定义：
      - dp[u][...]：以 u 为根的子树...
   4. 复杂度：
      - 通常 O(N) 或 O(N^2)（树上背包）。
*/

// 典型代码骨架 (Tree DP)
void dfs(int u, int fa) {
    // 初始化 dp[u]
    for (int v : adj[u]) {
        if (v == fa) continue;
        dfs(v, u); // 1. 先下钻（递归）
        // 2. 回溯更新 dp[u] (利用子节点 v 的结果更新 u)
        dp[u] += dp[v]; 
    }
}


/* 
   【类型二：伪·树状 DP（实为区间 DP）】
   1. 题目特征：
      - 输入是一个序列（数组、字符串），没有给出具体的边。
      - 题目要求：通过合并、切分、选根，构造出一棵最优的树（或结构）。
      - 关键词：“中序遍历为 1..n”、“矩阵连乘”、“最优二叉搜索树”。
   2. 核心逻辑：
      - 依赖关系：大区间依赖小区间。
      - 遍历方式：枚举区间长度 len -> 枚举左端点 l -> 枚举分割点 k。
   3. 状态定义：
      - dp[l][r]：区间 [l, r] 形成一棵子树/合并成一个整体的最优值。
      - root[l][r]：区间 [l, r] 选哪个点做根/分割点（用于输出方案）。
   4. 复杂度：
      - 通常 O(N^3)。
*/

// 典型代码骨架 (Interval DP)
// 针对 P1040 加分二叉树
int root[MAXN][MAXN]; // 记录决策路径

void solve_interval() {
    // 0. 初始化
    // 必须处理空子树的情况（加分二叉树中空子树分为1）
    // 以及长度为1的基础情况
    
    // 1. 枚举长度 (从小到大)
    for (int len = 2; len <= n; len++) {
        // 2. 枚举左端点
        for (int l = 1; l <= n - len + 1; l++) {
            int r = l + len - 1;
            
            // 3. 枚举分割点 (即：谁当根？)
            // 注意：k 必须从 l 走到 r (包含端点，代表左/右子树为空的情况)
            for (int k = l; k <= r; k++) {
                // 计算分数：左子树 * 右子树 + 根
                // 注意处理 k=l 或 k=r 时的边界（空子树分数为1）
                long long val = dp[l][k-1] * dp[k+1][r] + score[k];
                
                if (val > dp[l][r]) {
                    dp[l][r] = val;
                    root[l][r] = k; // 【关键】记录谁是老大
                }
            }
        }
    }
}

// 【关键】递归输出构造好的树（前序遍历：根->左->右）
void print_tree(int l, int r) {
    if (l > r) return; // 递归边界
    int mid = root[l][r]; // 取出当前区间的根
    cout << mid << " ";   // 输出根
    print_tree(l, mid - 1); // 递归左边
    print_tree(mid + 1, r); // 递归右边
}


// ==================== 一句话必杀技 ====================
// 如果题目给了边 (u, v)，让你在树上跑 ——> 树状 DP (DFS)
// 如果题目给了一排数，让你凑出一棵树 ——> 区间 DP (三层循环)


// ==================== 实战防坑指南 (血泪经验) ====================
/*
   1. 初始化陷阱：
      区间 DP 往往涉及乘法，空区间（如 dp[i][i-1]）必须初始化为 1 而不是 0。
      
   2. 循环边界：
      枚举分割点 k 时，一定要看清能不能取端点。
      对于“造树”类题目，k 通常可以取 l 和 r（代表只有单侧子树）。
      
   3. 数据范围：
      树的加分往往指数级增长，一定要开 long long。
      
   4. 变量定义：
      如果用 vector，必须先 cin >> n 再 resize，否则直接 RE。
*/
