#include<queue>
#include<iostream>
using namespace std;

//初始化：标记起点为已访问，将起点入队；
//循环遍历：队列非空时，出队队首节点，访问该节点；
//重点：要判断之前走过的地方不能再走了
//扩展节点：遍历队首节点的所有邻接节点，若未访问则标记为已访问并入队；
//终止条件：队列为空（所有可达节点遍历完毕）。


//queue相关知识：
// BFS 中存储节点编号（int 类型）
//定义：queue<int> q;

//q.push(val)	队尾入队：将 val 加入队列尾部（BFS 中 “邻接节点入队” 用这个）
//q.pop()	队首出队：删除队列第一个元素（无返回值！BFS 中 “处理完当前节点后弹出” 用这个）

//q.front()	返回队首元素的引用（BFS 中 “获取当前要处理的节点” 用这个）
//q.back()	返回队尾元素的引用（BFS 中极少用，除非需要操作最后入队的节点）

//q.empty()	判断队列是否为空（返回 bool，BFS 循环条件 while (!q.empty()) 用这个）
//q.size()	返回队列中元素的个数（BFS 中可用于统计遍历的节点数，或调试时查看队列状态）

//注意：q.pop无返回值，仅用于删除文件
//queue中使用多个元素，则构建struct


//迷宫最短路径检索
typedef struct {
    int x;
    int y;
    int num;//纪录步数
}locate;
int dx[4]={0,1,0,-1};
int dy[4]={1,0,-1,0};
//迷宫n行m列
//num为已知条件，path记录可行路径
//num中1表示可以行走，path中1表示已经走过（不可行走）
//int num[n][m];
int islaw(int tx,int ty,int n,int m,int num[][m],int path[][m]) {
    if(tx<n&&ty<m&&num[tx][ty]==1&&path[tx][ty]==0&&tx>=0&&ty>=0)
        return 1;
    else return 0;
}


//x,y为输入的起始点位置
int BFS(int x,int y,int m,int n,int num[][m],int path[][m]) {
queue<locate> q;//队列q(注意：不能是全局变量，不然会有上次BFS的残留值)
path[x][y]=1;//从起始元素开始，判定已经检测过
q.push(locate(x,y,0));
    while(!q.empty()) {
        locate now=q.front();//得到队列首元素，进行处理
        q.pop();//删除首元素
        if (now.x==m-1&&now.y==n-1)//到终点
            return now.num;//返回当前点走过的路程
        for (int i=0;i<4;i++) {//循环实现四个方向移动
            int tx=now.x+dx[i];
            int ty=now.y+dy[i];
            if (islaw(tx,ty,n,m,num,path))//如果合法，就加入队列
            {
             path[x][y]=1;//加入队列，则判断该位置已走过
             q.push(locate(tx,ty,now.num+1));//步数要加一
//注意，BFS中不需要多次递归使用函数                
            }
        }
    }
    return -1;//如果不成立，就返回负一
}


//已知BFS仅能处理等权问题，非等权问题需要加上优先队列
//我们的问题是「找从起点到终点的最小花费路径」，关键看路径的「总花费」，而不是「走了多少步」：
//无权图：每一步的花费都相同（比如走路，每步花 1 分钟）。此时普通 BFS（队列，按 “入队顺序” 处理，本质是 “步数优先”）是正确的 —— 因为步数越少，总花费越少，首次到达终点的路径就是最短路径。
//带权图：每一步的花费不同（本题中花费可以是 0、1、2、3）。此时普通 BFS（步数优先）会出错 —— 因为步数少的路径，总花费可能更大；而步数多的路径，总花费可能更小。

priority_queue<struct,cmp>q;
//priority_queue可以理解为可以排序的队列，可以输入cmp函数，如果没有cmp函数的话，默认弹出最大的元素（大顶堆）
//C++ 的priority_queue（优先队列）本质是一个「堆数据结构」，它的默认行为是：每次弹出队列中「最大」的元素
//此处的最大的比较方法是基于<，故会顺次比较元素中struct的各项，要修改弹出逻辑，就要重载运算符

//P3956
struct node{
    int x,y;  // 核心1：当前所在的网格坐标 (x,y)
    int c;    // 核心2：当前坐标(x,y)的「颜色」（提前存在node里，避免每次查col数组，优化效率）
    int w;    // 核心3：到达当前坐标(x,y)的「总花费」（这是排序的核心依据）
};
//只需要重载小于号即可
bool cmp <(struct b)const{  // const不可丢！记住！
    return w > b.w;  // 核心逻辑：当前struct的w > 另一个struct的w（b.w）时，返回true
}
//此时priority_queue<struct,cmp>q;就可以每次弹出花费最少的元素




